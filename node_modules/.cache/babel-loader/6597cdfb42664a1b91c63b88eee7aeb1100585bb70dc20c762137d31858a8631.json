{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoConnection = exports.SizedMessageTransform = exports.Connection = exports.hasSessionSupport = void 0;\nconst stream_1 = require(\"stream\");\nconst timers_1 = require(\"timers\");\nconst util_1 = require(\"util\");\nconst constants_1 = require(\"../constants\");\nconst error_1 = require(\"../error\");\nconst mongo_logger_1 = require(\"../mongo_logger\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst sessions_1 = require(\"../sessions\");\nconst utils_1 = require(\"../utils\");\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\nconst commands_1 = require(\"./commands\");\nconst stream_description_1 = require(\"./stream_description\");\nconst compression_1 = require(\"./wire_protocol/compression\");\nconst on_data_1 = require(\"./wire_protocol/on_data\");\nconst shared_1 = require(\"./wire_protocol/shared\");\n/** @internal */\nfunction hasSessionSupport(conn) {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null;\n}\nexports.hasSessionSupport = hasSessionSupport;\nfunction streamIdentifier(stream, options) {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n  const {\n    remoteAddress,\n    remotePort\n  } = stream;\n  if (typeof remoteAddress === 'string' && typeof remotePort === 'number') {\n    return utils_1.HostAddress.fromHostPort(remoteAddress, remotePort).toString();\n  }\n  return (0, utils_1.uuidV4)().toString('hex');\n}\n/** @internal */\nclass Connection extends mongo_types_1.TypedEventEmitter {\n  constructor(stream, options) {\n    super();\n    this.lastHelloMS = -1;\n    this.helloOk = false;\n    this.delayedTimeoutId = null;\n    this.clusterTime = null;\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.mongoLogger = options.mongoLogger;\n    this.established = false;\n    this.description = new stream_description_1.StreamDescription(this.address, options);\n    this.generation = options.generation;\n    this.lastUseTime = (0, utils_1.now)();\n    this.socket = stream;\n    // TODO: Remove signal from connection layer\n    this.controller = new AbortController();\n    const {\n      signal\n    } = this.controller;\n    this.signal = signal;\n    const {\n      promise: aborted,\n      reject\n    } = (0, utils_1.promiseWithResolvers)();\n    aborted.then(undefined, () => null); // Prevent unhandled rejection\n    this.signal.addEventListener('abort', function onAbort() {\n      reject(signal.reason);\n    }, {\n      once: true\n    });\n    this.aborted = aborted;\n    this.messageStream = this.socket.on('error', this.onError.bind(this)).pipe(new SizedMessageTransform({\n      connection: this\n    })).on('error', this.onError.bind(this));\n    this.socket.on('close', this.onClose.bind(this));\n    this.socket.on('timeout', this.onTimeout.bind(this));\n    const socketWrite = (0, util_1.promisify)(this.socket.write.bind(this.socket));\n    this.socketWrite = async buffer => {\n      return Promise.race([socketWrite(buffer), this.aborted]);\n    };\n  }\n  /** Indicates that the connection (including underlying TCP socket) has been closed. */\n  get closed() {\n    return this.signal.aborted;\n  }\n  get hello() {\n    return this.description.hello;\n  }\n  // the `connect` method stores the result of the handshake hello on the connection\n  set hello(response) {\n    this.description.receiveResponse(response);\n    Object.freeze(this.description);\n  }\n  get serviceId() {\n    return this.hello?.serviceId;\n  }\n  get loadBalanced() {\n    return this.description.loadBalanced;\n  }\n  get idleTime() {\n    return (0, utils_1.calculateDurationInMs)(this.lastUseTime);\n  }\n  get hasSessionSupport() {\n    return this.description.logicalSessionTimeoutMinutes != null;\n  }\n  get supportsOpMsg() {\n    return this.description != null && (0, utils_1.maxWireVersion)(this) >= 6 && !this.description.__nodejs_mock_server__;\n  }\n  get shouldEmitAndLogCommand() {\n    return (this.monitorCommands || this.established && !this.authContext?.reauthenticating && this.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.COMMAND, mongo_logger_1.SeverityLevel.DEBUG)) ?? false;\n  }\n  markAvailable() {\n    this.lastUseTime = (0, utils_1.now)();\n  }\n  onError(error) {\n    this.cleanup(error);\n  }\n  onClose() {\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(new error_1.MongoNetworkError(message));\n  }\n  onTimeout() {\n    this.delayedTimeoutId = (0, timers_1.setTimeout)(() => {\n      const message = `connection ${this.id} to ${this.address} timed out`;\n      const beforeHandshake = this.hello == null;\n      this.cleanup(new error_1.MongoNetworkTimeoutError(message, {\n        beforeHandshake\n      }));\n    }, 1).unref(); // No need for this timer to hold the event loop open\n  }\n  destroy(options, callback) {\n    if (this.closed) {\n      if (typeof callback === 'function') process.nextTick(callback);\n      return;\n    }\n    if (typeof callback === 'function') {\n      this.once('close', () => process.nextTick(() => callback()));\n    }\n    // load balanced mode requires that these listeners remain on the connection\n    // after cleanup on timeouts, errors or close so we remove them before calling\n    // cleanup.\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(new error_1.MongoNetworkError(message));\n  }\n  /**\n   * A method that cleans up the connection.  When `force` is true, this method\n   * forcibly destroys the socket.\n   *\n   * If an error is provided, any in-flight operations will be closed with the error.\n   *\n   * This method does nothing if the connection is already closed.\n   */\n  cleanup(error) {\n    if (this.closed) {\n      return;\n    }\n    this.socket.destroy();\n    this.controller.abort(error);\n    this.emit(Connection.CLOSE);\n  }\n  prepareCommand(db, command, options) {\n    let cmd = {\n      ...command\n    };\n    const readPreference = (0, shared_1.getReadPreference)(options);\n    const session = options?.session;\n    let clusterTime = this.clusterTime;\n    if (this.serverApi) {\n      const {\n        version,\n        strict,\n        deprecationErrors\n      } = this.serverApi;\n      cmd.apiVersion = version;\n      if (strict != null) cmd.apiStrict = strict;\n      if (deprecationErrors != null) cmd.apiDeprecationErrors = deprecationErrors;\n    }\n    if (this.hasSessionSupport && session) {\n      if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n        clusterTime = session.clusterTime;\n      }\n      const sessionError = (0, sessions_1.applySession)(session, cmd, options);\n      if (sessionError) throw sessionError;\n    } else if (session?.explicit) {\n      throw new error_1.MongoCompatibilityError('Current topology does not support sessions');\n    }\n    // if we have a known cluster time, gossip it\n    if (clusterTime) {\n      cmd.$clusterTime = clusterTime;\n    }\n    if ((0, shared_1.isSharded)(this) && !this.supportsOpMsg && readPreference && readPreference.mode !== 'primary') {\n      cmd = {\n        $query: cmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n    const commandOptions = {\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      // This value is not overridable\n      secondaryOk: readPreference.secondaryOk(),\n      ...options,\n      readPreference // ensure we pass in ReadPreference instance\n    };\n    const message = this.supportsOpMsg ? new commands_1.OpMsgRequest(db, cmd, commandOptions) : new commands_1.OpQueryRequest(db, cmd, commandOptions);\n    return message;\n  }\n  async *sendWire(message, options) {\n    this.throwIfAborted();\n    if (typeof options.socketTimeoutMS === 'number') {\n      this.socket.setTimeout(options.socketTimeoutMS);\n    } else if (this.socketTimeoutMS !== 0) {\n      this.socket.setTimeout(this.socketTimeoutMS);\n    }\n    try {\n      await this.writeCommand(message, {\n        agreedCompressor: this.description.compressor ?? 'none',\n        zlibCompressionLevel: this.description.zlibCompressionLevel\n      });\n      if (options.noResponse) {\n        yield {\n          ok: 1\n        };\n        return;\n      }\n      this.throwIfAborted();\n      for await (const response of this.readMany()) {\n        this.socket.setTimeout(0);\n        response.parse(options);\n        const [document] = response.documents;\n        if (!Buffer.isBuffer(document)) {\n          const {\n            session\n          } = options;\n          if (session) {\n            (0, sessions_1.updateSessionFromResponse)(session, document);\n          }\n          if (document.$clusterTime) {\n            this.clusterTime = document.$clusterTime;\n            this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n          }\n        }\n        yield document;\n        this.throwIfAborted();\n        if (typeof options.socketTimeoutMS === 'number') {\n          this.socket.setTimeout(options.socketTimeoutMS);\n        } else if (this.socketTimeoutMS !== 0) {\n          this.socket.setTimeout(this.socketTimeoutMS);\n        }\n      }\n    } finally {\n      this.socket.setTimeout(0);\n    }\n  }\n  async *sendCommand(ns, command, options = {}) {\n    const message = this.prepareCommand(ns.db, command, options);\n    let started = 0;\n    if (this.shouldEmitAndLogCommand) {\n      started = (0, utils_1.now)();\n      this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_STARTED, message.databaseName, this.established, new command_monitoring_events_1.CommandStartedEvent(this, message, this.description.serverConnectionId));\n    }\n    let document;\n    try {\n      this.throwIfAborted();\n      for await (document of this.sendWire(message, options)) {\n        if (!Buffer.isBuffer(document) && document.writeConcernError) {\n          throw new error_1.MongoWriteConcernError(document.writeConcernError, document);\n        }\n        if (!Buffer.isBuffer(document) && (document.ok === 0 || document.$err || document.errmsg || document.code)) {\n          throw new error_1.MongoServerError(document);\n        }\n        if (this.shouldEmitAndLogCommand) {\n          this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_SUCCEEDED, message.databaseName, this.established, new command_monitoring_events_1.CommandSucceededEvent(this, message, options.noResponse ? undefined : document, started, this.description.serverConnectionId));\n        }\n        yield document;\n        this.throwIfAborted();\n      }\n    } catch (error) {\n      if (this.shouldEmitAndLogCommand) {\n        if (error.name === 'MongoWriteConcernError') {\n          this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_SUCCEEDED, message.databaseName, this.established, new command_monitoring_events_1.CommandSucceededEvent(this, message, options.noResponse ? undefined : document, started, this.description.serverConnectionId));\n        } else {\n          this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_FAILED, message.databaseName, this.established, new command_monitoring_events_1.CommandFailedEvent(this, message, error, started, this.description.serverConnectionId));\n        }\n      }\n      throw error;\n    }\n  }\n  async command(ns, command, options = {}) {\n    this.throwIfAborted();\n    for await (const document of this.sendCommand(ns, command, options)) {\n      return document;\n    }\n    throw new error_1.MongoUnexpectedServerResponseError('Unable to get response from server');\n  }\n  exhaustCommand(ns, command, options, replyListener) {\n    const exhaustLoop = async () => {\n      this.throwIfAborted();\n      for await (const reply of this.sendCommand(ns, command, options)) {\n        replyListener(undefined, reply);\n        this.throwIfAborted();\n      }\n      throw new error_1.MongoUnexpectedServerResponseError('Server ended moreToCome unexpectedly');\n    };\n    exhaustLoop().catch(replyListener);\n  }\n  throwIfAborted() {\n    this.signal.throwIfAborted();\n  }\n  /**\n   * @internal\n   *\n   * Writes an OP_MSG or OP_QUERY request to the socket, optionally compressing the command. This method\n   * waits until the socket's buffer has emptied (the Nodejs socket `drain` event has fired).\n   */\n  async writeCommand(command, options) {\n    const finalCommand = options.agreedCompressor === 'none' || !commands_1.OpCompressedRequest.canCompress(command) ? command : new commands_1.OpCompressedRequest(command, {\n      agreedCompressor: options.agreedCompressor ?? 'none',\n      zlibCompressionLevel: options.zlibCompressionLevel ?? 0\n    });\n    const buffer = Buffer.concat(await finalCommand.toBin());\n    return this.socketWrite(buffer);\n  }\n  /**\n   * @internal\n   *\n   * Returns an async generator that yields full wire protocol messages from the underlying socket.  This function\n   * yields messages until `moreToCome` is false or not present in a response, or the caller cancels the request\n   * by calling `return` on the generator.\n   *\n   * Note that `for-await` loops call `return` automatically when the loop is exited.\n   */\n  async *readMany() {\n    for await (const message of (0, on_data_1.onData)(this.messageStream, {\n      signal: this.signal\n    })) {\n      const response = await (0, compression_1.decompressResponse)(message);\n      yield response;\n      if (!response.moreToCome) {\n        return;\n      }\n    }\n  }\n}\n/** @event */\nConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;\n/** @event */\nConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;\n/** @event */\nConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;\n/** @event */\nConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;\n/** @event */\nConnection.CLOSE = constants_1.CLOSE;\n/** @event */\nConnection.PINNED = constants_1.PINNED;\n/** @event */\nConnection.UNPINNED = constants_1.UNPINNED;\nexports.Connection = Connection;\n/** @internal */\nclass SizedMessageTransform extends stream_1.Transform {\n  constructor({\n    connection\n  }) {\n    super({\n      objectMode: false\n    });\n    this.bufferPool = new utils_1.BufferPool();\n    this.connection = connection;\n  }\n  _transform(chunk, encoding, callback) {\n    if (this.connection.delayedTimeoutId != null) {\n      (0, timers_1.clearTimeout)(this.connection.delayedTimeoutId);\n      this.connection.delayedTimeoutId = null;\n    }\n    this.bufferPool.append(chunk);\n    const sizeOfMessage = this.bufferPool.getInt32();\n    if (sizeOfMessage == null) {\n      return callback();\n    }\n    if (sizeOfMessage < 0) {\n      return callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, too small`));\n    }\n    if (sizeOfMessage > this.bufferPool.length) {\n      return callback();\n    }\n    const message = this.bufferPool.read(sizeOfMessage);\n    return callback(null, message);\n  }\n}\nexports.SizedMessageTransform = SizedMessageTransform;\n/** @internal */\nclass CryptoConnection extends Connection {\n  constructor(stream, options) {\n    super(stream, options);\n    this.autoEncrypter = options.autoEncrypter;\n  }\n  /** @internal @override */\n  async command(ns, cmd, options) {\n    const {\n      autoEncrypter\n    } = this;\n    if (!autoEncrypter) {\n      throw new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption');\n    }\n    const serverWireVersion = (0, utils_1.maxWireVersion)(this);\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options);\n    }\n    if (serverWireVersion < 8) {\n      throw new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2');\n    }\n    // Save sort or indexKeys based on the command being run\n    // the encrypt API serializes our JS objects to BSON to pass to the native code layer\n    // and then deserializes the encrypted result, the protocol level components\n    // of the command (ex. sort) are then converted to JS objects potentially losing\n    // import key order information. These fields are never encrypted so we can save the values\n    // from before the encryption and replace them after encryption has been performed\n    const sort = cmd.find || cmd.findAndModify ? cmd.sort : null;\n    const indexKeys = cmd.createIndexes ? cmd.indexes.map(index => index.key) : null;\n    const encrypted = await autoEncrypter.encrypt(ns.toString(), cmd, options);\n    // Replace the saved values\n    if (sort != null && (cmd.find || cmd.findAndModify)) {\n      encrypted.sort = sort;\n    }\n    if (indexKeys != null && cmd.createIndexes) {\n      for (const [offset, index] of indexKeys.entries()) {\n        // @ts-expect-error `encrypted` is a generic \"command\", but we've narrowed for only `createIndexes` commands here\n        encrypted.indexes[offset].key = index;\n      }\n    }\n    const response = await super.command(ns, encrypted, options);\n    return autoEncrypter.decrypt(response, options);\n  }\n}\nexports.CryptoConnection = CryptoConnection;","map":{"version":3,"names":["stream_1","require","timers_1","util_1","constants_1","error_1","mongo_logger_1","mongo_types_1","sessions_1","utils_1","command_monitoring_events_1","commands_1","stream_description_1","compression_1","on_data_1","shared_1","hasSessionSupport","conn","description","logicalSessionTimeoutMinutes","exports","streamIdentifier","stream","options","proxyHost","hostAddress","toString","remoteAddress","remotePort","HostAddress","fromHostPort","uuidV4","Connection","TypedEventEmitter","constructor","lastHelloMS","helloOk","delayedTimeoutId","clusterTime","id","address","socketTimeoutMS","monitorCommands","serverApi","mongoLogger","established","StreamDescription","generation","lastUseTime","now","socket","controller","AbortController","signal","promise","aborted","reject","promiseWithResolvers","then","undefined","addEventListener","onAbort","reason","once","messageStream","on","onError","bind","pipe","SizedMessageTransform","connection","onClose","onTimeout","socketWrite","promisify","write","buffer","Promise","race","closed","hello","response","receiveResponse","Object","freeze","serviceId","loadBalanced","idleTime","calculateDurationInMs","supportsOpMsg","maxWireVersion","__nodejs_mock_server__","shouldEmitAndLogCommand","authContext","reauthenticating","willLog","MongoLoggableComponent","COMMAND","SeverityLevel","DEBUG","markAvailable","error","cleanup","message","MongoNetworkError","setTimeout","beforeHandshake","MongoNetworkTimeoutError","unref","destroy","callback","process","nextTick","removeAllListeners","PINNED","UNPINNED","abort","emit","CLOSE","prepareCommand","db","command","cmd","readPreference","getReadPreference","session","version","strict","deprecationErrors","apiVersion","apiStrict","apiDeprecationErrors","greaterThan","sessionError","applySession","explicit","MongoCompatibilityError","$clusterTime","isSharded","mode","$query","$readPreference","toJSON","commandOptions","numberToSkip","numberToReturn","checkKeys","secondaryOk","OpMsgRequest","OpQueryRequest","sendWire","throwIfAborted","writeCommand","agreedCompressor","compressor","zlibCompressionLevel","noResponse","ok","readMany","parse","document","documents","Buffer","isBuffer","updateSessionFromResponse","CLUSTER_TIME_RECEIVED","sendCommand","ns","started","emitAndLogCommand","COMMAND_STARTED","databaseName","CommandStartedEvent","serverConnectionId","writeConcernError","MongoWriteConcernError","$err","errmsg","code","MongoServerError","COMMAND_SUCCEEDED","CommandSucceededEvent","name","COMMAND_FAILED","CommandFailedEvent","MongoUnexpectedServerResponseError","exhaustCommand","replyListener","exhaustLoop","reply","catch","finalCommand","OpCompressedRequest","canCompress","concat","toBin","onData","decompressResponse","moreToCome","Transform","objectMode","bufferPool","BufferPool","_transform","chunk","encoding","clearTimeout","append","sizeOfMessage","getInt32","MongoParseError","length","read","CryptoConnection","autoEncrypter","MongoMissingDependencyError","serverWireVersion","sort","find","findAndModify","indexKeys","createIndexes","indexes","map","index","key","encrypted","encrypt","offset","entries","decrypt"],"sources":["C:\\Users\\zkhan\\OneDrive\\Desktop\\my-app1\\node_modules\\mongodb\\src\\cmap\\connection.ts"],"sourcesContent":["import { type Readable, Transform, type TransformCallback } from 'stream';\nimport { clearTimeout, setTimeout } from 'timers';\nimport { promisify } from 'util';\n\nimport type { BSONSerializeOptions, Document, ObjectId } from '../bson';\nimport type { AutoEncrypter } from '../client-side-encryption/auto_encrypter';\nimport {\n  CLOSE,\n  CLUSTER_TIME_RECEIVED,\n  COMMAND_FAILED,\n  COMMAND_STARTED,\n  COMMAND_SUCCEEDED,\n  PINNED,\n  UNPINNED\n} from '../constants';\nimport {\n  MongoCompatibilityError,\n  MongoMissingDependencyError,\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  MongoParseError,\n  MongoServerError,\n  MongoUnexpectedServerResponseError,\n  MongoWriteConcernError\n} from '../error';\nimport type { ServerApi, SupportedNodeConnectionOptions } from '../mongo_client';\nimport { type MongoClientAuthProviders } from '../mongo_client_auth_providers';\nimport { MongoLoggableComponent, type MongoLogger, SeverityLevel } from '../mongo_logger';\nimport { type CancellationToken, TypedEventEmitter } from '../mongo_types';\nimport type { ReadPreferenceLike } from '../read_preference';\nimport { applySession, type ClientSession, updateSessionFromResponse } from '../sessions';\nimport {\n  BufferPool,\n  calculateDurationInMs,\n  type Callback,\n  HostAddress,\n  maxWireVersion,\n  type MongoDBNamespace,\n  now,\n  promiseWithResolvers,\n  uuidV4\n} from '../utils';\nimport type { WriteConcern } from '../write_concern';\nimport type { AuthContext } from './auth/auth_provider';\nimport type { MongoCredentials } from './auth/mongo_credentials';\nimport {\n  CommandFailedEvent,\n  CommandStartedEvent,\n  CommandSucceededEvent\n} from './command_monitoring_events';\nimport {\n  OpCompressedRequest,\n  OpMsgRequest,\n  type OpMsgResponse,\n  OpQueryRequest,\n  type OpQueryResponse,\n  type WriteProtocolMessageType\n} from './commands';\nimport type { Stream } from './connect';\nimport type { ClientMetadata } from './handshake/client_metadata';\nimport { StreamDescription, type StreamDescriptionOptions } from './stream_description';\nimport { type CompressorName, decompressResponse } from './wire_protocol/compression';\nimport { onData } from './wire_protocol/on_data';\nimport { getReadPreference, isSharded } from './wire_protocol/shared';\n\n/** @internal */\nexport interface CommandOptions extends BSONSerializeOptions {\n  secondaryOk?: boolean;\n  /** Specify read preference if command supports it */\n  readPreference?: ReadPreferenceLike;\n  monitoring?: boolean;\n  socketTimeoutMS?: number;\n  /** Session to use for the operation */\n  session?: ClientSession;\n  documentsReturnedIn?: string;\n  noResponse?: boolean;\n  omitReadPreference?: boolean;\n\n  // TODO(NODE-2802): Currently the CommandOptions take a property willRetryWrite which is a hint\n  // from executeOperation that the txnNum should be applied to this command.\n  // Applying a session to a command should happen as part of command construction,\n  // most likely in the CommandOperation#executeCommand method, where we have access to\n  // the details we need to determine if a txnNum should also be applied.\n  willRetryWrite?: boolean;\n\n  writeConcern?: WriteConcern;\n}\n\n/** @public */\nexport interface ProxyOptions {\n  proxyHost?: string;\n  proxyPort?: number;\n  proxyUsername?: string;\n  proxyPassword?: string;\n}\n\n/** @public */\nexport interface ConnectionOptions\n  extends SupportedNodeConnectionOptions,\n    StreamDescriptionOptions,\n    ProxyOptions {\n  // Internal creation info\n  id: number | '<monitor>';\n  generation: number;\n  hostAddress: HostAddress;\n  /** @internal */\n  autoEncrypter?: AutoEncrypter;\n  serverApi?: ServerApi;\n  monitorCommands: boolean;\n  /** @internal */\n  connectionType?: any;\n  credentials?: MongoCredentials;\n  /** @internal */\n  authProviders: MongoClientAuthProviders;\n  connectTimeoutMS?: number;\n  tls: boolean;\n  noDelay?: boolean;\n  socketTimeoutMS?: number;\n  cancellationToken?: CancellationToken;\n  metadata: ClientMetadata;\n  /** @internal */\n  mongoLogger?: MongoLogger | undefined;\n}\n\n/** @internal */\nexport interface DestroyOptions {\n  /** Force the destruction. */\n  force: boolean;\n}\n\n/** @public */\nexport type ConnectionEvents = {\n  commandStarted(event: CommandStartedEvent): void;\n  commandSucceeded(event: CommandSucceededEvent): void;\n  commandFailed(event: CommandFailedEvent): void;\n  clusterTimeReceived(clusterTime: Document): void;\n  close(): void;\n  pinned(pinType: string): void;\n  unpinned(pinType: string): void;\n};\n\n/** @internal */\nexport function hasSessionSupport(conn: Connection): boolean {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null;\n}\n\nfunction streamIdentifier(stream: Stream, options: ConnectionOptions): string {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n\n  const { remoteAddress, remotePort } = stream;\n  if (typeof remoteAddress === 'string' && typeof remotePort === 'number') {\n    return HostAddress.fromHostPort(remoteAddress, remotePort).toString();\n  }\n\n  return uuidV4().toString('hex');\n}\n\n/** @internal */\nexport class Connection extends TypedEventEmitter<ConnectionEvents> {\n  public id: number | '<monitor>';\n  public address: string;\n  public lastHelloMS = -1;\n  public serverApi?: ServerApi;\n  public helloOk = false;\n  public authContext?: AuthContext;\n  public delayedTimeoutId: NodeJS.Timeout | null = null;\n  public generation: number;\n  public readonly description: Readonly<StreamDescription>;\n  /**\n   * Represents if the connection has been established:\n   *  - TCP handshake\n   *  - TLS negotiated\n   *  - mongodb handshake (saslStart, saslContinue), includes authentication\n   *\n   * Once connection is established, command logging can log events (if enabled)\n   */\n  public established: boolean;\n\n  private lastUseTime: number;\n  private clusterTime: Document | null = null;\n\n  private readonly socketTimeoutMS: number;\n  private readonly monitorCommands: boolean;\n  private readonly socket: Stream;\n  private readonly controller: AbortController;\n  private readonly signal: AbortSignal;\n  private readonly messageStream: Readable;\n  private readonly socketWrite: (buffer: Uint8Array) => Promise<void>;\n  private readonly aborted: Promise<never>;\n\n  /** @event */\n  static readonly COMMAND_STARTED = COMMAND_STARTED;\n  /** @event */\n  static readonly COMMAND_SUCCEEDED = COMMAND_SUCCEEDED;\n  /** @event */\n  static readonly COMMAND_FAILED = COMMAND_FAILED;\n  /** @event */\n  static readonly CLUSTER_TIME_RECEIVED = CLUSTER_TIME_RECEIVED;\n  /** @event */\n  static readonly CLOSE = CLOSE;\n  /** @event */\n  static readonly PINNED = PINNED;\n  /** @event */\n  static readonly UNPINNED = UNPINNED;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super();\n\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.mongoLogger = options.mongoLogger;\n    this.established = false;\n\n    this.description = new StreamDescription(this.address, options);\n    this.generation = options.generation;\n    this.lastUseTime = now();\n\n    this.socket = stream;\n\n    // TODO: Remove signal from connection layer\n    this.controller = new AbortController();\n    const { signal } = this.controller;\n    this.signal = signal;\n    const { promise: aborted, reject } = promiseWithResolvers<never>();\n    aborted.then(undefined, () => null); // Prevent unhandled rejection\n    this.signal.addEventListener(\n      'abort',\n      function onAbort() {\n        reject(signal.reason);\n      },\n      { once: true }\n    );\n    this.aborted = aborted;\n\n    this.messageStream = this.socket\n      .on('error', this.onError.bind(this))\n      .pipe(new SizedMessageTransform({ connection: this }))\n      .on('error', this.onError.bind(this));\n    this.socket.on('close', this.onClose.bind(this));\n    this.socket.on('timeout', this.onTimeout.bind(this));\n\n    const socketWrite = promisify(this.socket.write.bind(this.socket));\n    this.socketWrite = async buffer => {\n      return Promise.race([socketWrite(buffer), this.aborted]);\n    };\n  }\n\n  /** Indicates that the connection (including underlying TCP socket) has been closed. */\n  public get closed(): boolean {\n    return this.signal.aborted;\n  }\n\n  public get hello() {\n    return this.description.hello;\n  }\n\n  // the `connect` method stores the result of the handshake hello on the connection\n  public set hello(response: Document | null) {\n    this.description.receiveResponse(response);\n    Object.freeze(this.description);\n  }\n\n  public get serviceId(): ObjectId | undefined {\n    return this.hello?.serviceId;\n  }\n\n  public get loadBalanced(): boolean {\n    return this.description.loadBalanced;\n  }\n\n  public get idleTime(): number {\n    return calculateDurationInMs(this.lastUseTime);\n  }\n\n  private get hasSessionSupport(): boolean {\n    return this.description.logicalSessionTimeoutMinutes != null;\n  }\n\n  private get supportsOpMsg(): boolean {\n    return (\n      this.description != null &&\n      maxWireVersion(this) >= 6 &&\n      !this.description.__nodejs_mock_server__\n    );\n  }\n\n  private get shouldEmitAndLogCommand(): boolean {\n    return (\n      (this.monitorCommands ||\n        (this.established &&\n          !this.authContext?.reauthenticating &&\n          this.mongoLogger?.willLog(MongoLoggableComponent.COMMAND, SeverityLevel.DEBUG))) ??\n      false\n    );\n  }\n\n  public markAvailable(): void {\n    this.lastUseTime = now();\n  }\n\n  public onError(error?: Error) {\n    this.cleanup(error);\n  }\n\n  private onClose() {\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(new MongoNetworkError(message));\n  }\n\n  private onTimeout() {\n    this.delayedTimeoutId = setTimeout(() => {\n      const message = `connection ${this.id} to ${this.address} timed out`;\n      const beforeHandshake = this.hello == null;\n      this.cleanup(new MongoNetworkTimeoutError(message, { beforeHandshake }));\n    }, 1).unref(); // No need for this timer to hold the event loop open\n  }\n\n  public destroy(options: DestroyOptions, callback?: Callback): void {\n    if (this.closed) {\n      if (typeof callback === 'function') process.nextTick(callback);\n      return;\n    }\n    if (typeof callback === 'function') {\n      this.once('close', () => process.nextTick(() => callback()));\n    }\n\n    // load balanced mode requires that these listeners remain on the connection\n    // after cleanup on timeouts, errors or close so we remove them before calling\n    // cleanup.\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(new MongoNetworkError(message));\n  }\n\n  /**\n   * A method that cleans up the connection.  When `force` is true, this method\n   * forcibly destroys the socket.\n   *\n   * If an error is provided, any in-flight operations will be closed with the error.\n   *\n   * This method does nothing if the connection is already closed.\n   */\n  private cleanup(error?: Error): void {\n    if (this.closed) {\n      return;\n    }\n\n    this.socket.destroy();\n    this.controller.abort(error);\n    this.emit(Connection.CLOSE);\n  }\n\n  private prepareCommand(db: string, command: Document, options: CommandOptions) {\n    let cmd = { ...command };\n\n    const readPreference = getReadPreference(options);\n    const session = options?.session;\n\n    let clusterTime = this.clusterTime;\n\n    if (this.serverApi) {\n      const { version, strict, deprecationErrors } = this.serverApi;\n      cmd.apiVersion = version;\n      if (strict != null) cmd.apiStrict = strict;\n      if (deprecationErrors != null) cmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (this.hasSessionSupport && session) {\n      if (\n        session.clusterTime &&\n        clusterTime &&\n        session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)\n      ) {\n        clusterTime = session.clusterTime;\n      }\n\n      const sessionError = applySession(session, cmd, options);\n      if (sessionError) throw sessionError;\n    } else if (session?.explicit) {\n      throw new MongoCompatibilityError('Current topology does not support sessions');\n    }\n\n    // if we have a known cluster time, gossip it\n    if (clusterTime) {\n      cmd.$clusterTime = clusterTime;\n    }\n\n    if (\n      isSharded(this) &&\n      !this.supportsOpMsg &&\n      readPreference &&\n      readPreference.mode !== 'primary'\n    ) {\n      cmd = {\n        $query: cmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n\n    const commandOptions = {\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      // This value is not overridable\n      secondaryOk: readPreference.secondaryOk(),\n      ...options,\n      readPreference // ensure we pass in ReadPreference instance\n    };\n\n    const message = this.supportsOpMsg\n      ? new OpMsgRequest(db, cmd, commandOptions)\n      : new OpQueryRequest(db, cmd, commandOptions);\n\n    return message;\n  }\n\n  private async *sendWire(message: WriteProtocolMessageType, options: CommandOptions) {\n    this.throwIfAborted();\n\n    if (typeof options.socketTimeoutMS === 'number') {\n      this.socket.setTimeout(options.socketTimeoutMS);\n    } else if (this.socketTimeoutMS !== 0) {\n      this.socket.setTimeout(this.socketTimeoutMS);\n    }\n\n    try {\n      await this.writeCommand(message, {\n        agreedCompressor: this.description.compressor ?? 'none',\n        zlibCompressionLevel: this.description.zlibCompressionLevel\n      });\n\n      if (options.noResponse) {\n        yield { ok: 1 };\n        return;\n      }\n\n      this.throwIfAborted();\n\n      for await (const response of this.readMany()) {\n        this.socket.setTimeout(0);\n        response.parse(options);\n\n        const [document] = response.documents;\n\n        if (!Buffer.isBuffer(document)) {\n          const { session } = options;\n          if (session) {\n            updateSessionFromResponse(session, document);\n          }\n\n          if (document.$clusterTime) {\n            this.clusterTime = document.$clusterTime;\n            this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n          }\n        }\n\n        yield document;\n        this.throwIfAborted();\n\n        if (typeof options.socketTimeoutMS === 'number') {\n          this.socket.setTimeout(options.socketTimeoutMS);\n        } else if (this.socketTimeoutMS !== 0) {\n          this.socket.setTimeout(this.socketTimeoutMS);\n        }\n      }\n    } finally {\n      this.socket.setTimeout(0);\n    }\n  }\n\n  private async *sendCommand(\n    ns: MongoDBNamespace,\n    command: Document,\n    options: CommandOptions = {}\n  ) {\n    const message = this.prepareCommand(ns.db, command, options);\n\n    let started = 0;\n    if (this.shouldEmitAndLogCommand) {\n      started = now();\n      this.emitAndLogCommand(\n        this.monitorCommands,\n        Connection.COMMAND_STARTED,\n        message.databaseName,\n        this.established,\n        new CommandStartedEvent(this, message, this.description.serverConnectionId)\n      );\n    }\n\n    let document;\n    try {\n      this.throwIfAborted();\n      for await (document of this.sendWire(message, options)) {\n        if (!Buffer.isBuffer(document) && document.writeConcernError) {\n          throw new MongoWriteConcernError(document.writeConcernError, document);\n        }\n\n        if (\n          !Buffer.isBuffer(document) &&\n          (document.ok === 0 || document.$err || document.errmsg || document.code)\n        ) {\n          throw new MongoServerError(document);\n        }\n\n        if (this.shouldEmitAndLogCommand) {\n          this.emitAndLogCommand(\n            this.monitorCommands,\n            Connection.COMMAND_SUCCEEDED,\n            message.databaseName,\n            this.established,\n            new CommandSucceededEvent(\n              this,\n              message,\n              options.noResponse ? undefined : document,\n              started,\n              this.description.serverConnectionId\n            )\n          );\n        }\n\n        yield document;\n        this.throwIfAborted();\n      }\n    } catch (error) {\n      if (this.shouldEmitAndLogCommand) {\n        if (error.name === 'MongoWriteConcernError') {\n          this.emitAndLogCommand(\n            this.monitorCommands,\n            Connection.COMMAND_SUCCEEDED,\n            message.databaseName,\n            this.established,\n            new CommandSucceededEvent(\n              this,\n              message,\n              options.noResponse ? undefined : document,\n              started,\n              this.description.serverConnectionId\n            )\n          );\n        } else {\n          this.emitAndLogCommand(\n            this.monitorCommands,\n            Connection.COMMAND_FAILED,\n            message.databaseName,\n            this.established,\n            new CommandFailedEvent(\n              this,\n              message,\n              error,\n              started,\n              this.description.serverConnectionId\n            )\n          );\n        }\n      }\n      throw error;\n    }\n  }\n\n  public async command(\n    ns: MongoDBNamespace,\n    command: Document,\n    options: CommandOptions = {}\n  ): Promise<Document> {\n    this.throwIfAborted();\n    for await (const document of this.sendCommand(ns, command, options)) {\n      return document;\n    }\n    throw new MongoUnexpectedServerResponseError('Unable to get response from server');\n  }\n\n  public exhaustCommand(\n    ns: MongoDBNamespace,\n    command: Document,\n    options: CommandOptions,\n    replyListener: Callback\n  ) {\n    const exhaustLoop = async () => {\n      this.throwIfAborted();\n      for await (const reply of this.sendCommand(ns, command, options)) {\n        replyListener(undefined, reply);\n        this.throwIfAborted();\n      }\n      throw new MongoUnexpectedServerResponseError('Server ended moreToCome unexpectedly');\n    };\n    exhaustLoop().catch(replyListener);\n  }\n\n  private throwIfAborted() {\n    this.signal.throwIfAborted();\n  }\n\n  /**\n   * @internal\n   *\n   * Writes an OP_MSG or OP_QUERY request to the socket, optionally compressing the command. This method\n   * waits until the socket's buffer has emptied (the Nodejs socket `drain` event has fired).\n   */\n  private async writeCommand(\n    command: WriteProtocolMessageType,\n    options: { agreedCompressor?: CompressorName; zlibCompressionLevel?: number }\n  ): Promise<void> {\n    const finalCommand =\n      options.agreedCompressor === 'none' || !OpCompressedRequest.canCompress(command)\n        ? command\n        : new OpCompressedRequest(command, {\n            agreedCompressor: options.agreedCompressor ?? 'none',\n            zlibCompressionLevel: options.zlibCompressionLevel ?? 0\n          });\n\n    const buffer = Buffer.concat(await finalCommand.toBin());\n\n    return this.socketWrite(buffer);\n  }\n\n  /**\n   * @internal\n   *\n   * Returns an async generator that yields full wire protocol messages from the underlying socket.  This function\n   * yields messages until `moreToCome` is false or not present in a response, or the caller cancels the request\n   * by calling `return` on the generator.\n   *\n   * Note that `for-await` loops call `return` automatically when the loop is exited.\n   */\n  private async *readMany(): AsyncGenerator<OpMsgResponse | OpQueryResponse> {\n    for await (const message of onData(this.messageStream, { signal: this.signal })) {\n      const response = await decompressResponse(message);\n      yield response;\n\n      if (!response.moreToCome) {\n        return;\n      }\n    }\n  }\n}\n\n/** @internal */\nexport class SizedMessageTransform extends Transform {\n  bufferPool: BufferPool;\n  connection: Connection;\n\n  constructor({ connection }: { connection: Connection }) {\n    super({ objectMode: false });\n    this.bufferPool = new BufferPool();\n    this.connection = connection;\n  }\n\n  override _transform(chunk: Buffer, encoding: unknown, callback: TransformCallback): void {\n    if (this.connection.delayedTimeoutId != null) {\n      clearTimeout(this.connection.delayedTimeoutId);\n      this.connection.delayedTimeoutId = null;\n    }\n\n    this.bufferPool.append(chunk);\n    const sizeOfMessage = this.bufferPool.getInt32();\n\n    if (sizeOfMessage == null) {\n      return callback();\n    }\n\n    if (sizeOfMessage < 0) {\n      return callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}, too small`));\n    }\n\n    if (sizeOfMessage > this.bufferPool.length) {\n      return callback();\n    }\n\n    const message = this.bufferPool.read(sizeOfMessage);\n    return callback(null, message);\n  }\n}\n\n/** @internal */\nexport class CryptoConnection extends Connection {\n  /** @internal */\n  autoEncrypter?: AutoEncrypter;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super(stream, options);\n    this.autoEncrypter = options.autoEncrypter;\n  }\n\n  /** @internal @override */\n  override async command(\n    ns: MongoDBNamespace,\n    cmd: Document,\n    options: CommandOptions\n  ): Promise<Document> {\n    const { autoEncrypter } = this;\n    if (!autoEncrypter) {\n      throw new MongoMissingDependencyError('No AutoEncrypter available for encryption');\n    }\n\n    const serverWireVersion = maxWireVersion(this);\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options);\n    }\n\n    if (serverWireVersion < 8) {\n      throw new MongoCompatibilityError(\n        'Auto-encryption requires a minimum MongoDB version of 4.2'\n      );\n    }\n\n    // Save sort or indexKeys based on the command being run\n    // the encrypt API serializes our JS objects to BSON to pass to the native code layer\n    // and then deserializes the encrypted result, the protocol level components\n    // of the command (ex. sort) are then converted to JS objects potentially losing\n    // import key order information. These fields are never encrypted so we can save the values\n    // from before the encryption and replace them after encryption has been performed\n    const sort: Map<string, number> | null = cmd.find || cmd.findAndModify ? cmd.sort : null;\n    const indexKeys: Map<string, number>[] | null = cmd.createIndexes\n      ? cmd.indexes.map((index: { key: Map<string, number> }) => index.key)\n      : null;\n\n    const encrypted = await autoEncrypter.encrypt(ns.toString(), cmd, options);\n\n    // Replace the saved values\n    if (sort != null && (cmd.find || cmd.findAndModify)) {\n      encrypted.sort = sort;\n    }\n\n    if (indexKeys != null && cmd.createIndexes) {\n      for (const [offset, index] of indexKeys.entries()) {\n        // @ts-expect-error `encrypted` is a generic \"command\", but we've narrowed for only `createIndexes` commands here\n        encrypted.indexes[offset].key = index;\n      }\n    }\n\n    const response = await super.command(ns, encrypted, options);\n\n    return autoEncrypter.decrypt(response, options);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}